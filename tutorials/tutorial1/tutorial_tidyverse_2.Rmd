---
title: "STAT 451 - Visualizing Data - Autumn 2025"
author: "Ariane Ducellier"
date: "10/02/2025"
output: pdf_document
---

# Tutorial Tidyverse part 2

Today, we are going to continue reviewing useful R functions for reading and exploring data sets. We will focus on dealing with missing data and getting data from the web.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We will need the following R libraries:

```{r libraries}
library(httr)
library(jsonlite)
library(mice)
library(rvest)
library(tidyverse)
```

## 1. Dealing with missing data

We will read a data set and replace the ? by NA.

```{r get_data}
header <- c("age", "workclass", "fnlwgt", "education",
  "education_num", "marital_status", "occupation",
  "relationship", "race", "sex", "capital_gain",
  "capital_loss", "hours_per_week", "native_country", "target")
df <- read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data",
  col_names=header, trim_ws=TRUE)
df <-df %>%
  mutate(workclass = na_if(workclass, "?"),
         occupation = na_if(occupation, "?"),
         native_country = na_if(native_country, "?"))
```

### 1.1 Filling values with previous value

A first method is to fill the missing data with the previous value in the table. This is a good method when dealing with time series data for example.

```{r fill_previous}
df_fill1 <- df %>%
  fill(workclass, occupation, native_country, .direction="down")
```

### 1.2 Filling values with most frequent value

This method is useful for categorical variables.

```{r fill_frequent}
m_freq_workcls <- names(table(df$workclass))[which.max(table(df$workclass))]
m_freq_occup <- names(table(df$occupation))[which.max(table(df$occupation))]
df_fill2 <- df %>%
  replace_na(list(workclass = m_freq_workcls,
                  occupation = m_freq_occup))
```

### 1.3 Dropping rows with missing values

You can drop all the rows that have at least one missing value,

```{r omit}
df_no_na <- df %>% na.omit()
```

or drop only the rows that have missing values for specific columns.

```{r drop}
df_native <- df %>%
  drop_na(native_country)
```

### 1.4 Imputing with mice

Let us read the dataset.

```{r data}
data("txhousing")
txhousing$date <- date_decimal(txhousing$date, tz="GMT")
txhousing$city <- as.factor(txhousing$city)
```

We drop the rows that have 5 missing values because it will be difficult to impute with so many missing columns.

```{r drop_5nas}
idx <- which(rowSums(is.na(txhousing)) == 5)
txhousing <- txhousing[-idx,]
```

For the sales, volume and median columns, we impute the missing data with the median value of the variable.

```{r impute_median}
txhousing$sales[is.na(txhousing$sales)] <- median(txhousing$sales, na.rm=TRUE)
txhousing$volume[is.na(txhousing$volume)] <- median(txhousing$volume, na.rm=TRUE)
txhousing$median[is.na(txhousing$median)] <- median(txhousing$median, na.rm=TRUE)
```

We use the mice ([Multivariate Imputation by Chained Equations](https://www.jstatsoft.org/article/view/v045i03)) package to impute the missing values for the listings and inventory columns.

```{r impute_mice}
impute <- mice(data.frame(txhousing[,7:8]), seed=123)
impute_data <- complete(impute, 1)
txhousing_clean <- txhousing %>%
  mutate(listings = impute_data[,1],
         inventory = impute_data[,2])
```

### 1.5 Implicit missing values

In this example, the price for the 1st quarter of 2021 is missing, but you won't see it by just looking for the rows with NA in the data set.

```{r data_missing}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

It becomes obvious that the row is missing when you pivot the data set to a wider table, but then you no longer have tidy data.

```{r wider}
stocks %>%
  pivot_wider(
    names_from = qtr, 
    values_from = price
  )
```

The complete function will fill your tidy data set with the missing rows and use NAs for the missing values.

```{r complete}
stocks %>% complete(year, qtr)
```

## 2. Getting data from the web

This is an example on how to copy a data table from a web page.

- Go to the [Wiki page](https://en.wikipedia.org/wiki/List_of_countries_by_GDP_(nominal)).
- Right-click and select Inspect.
- Find the piece of code that highlights the table.
- Right-click and select Copy > XPath.

You first start by reading the entire content of the web page.

```{r read_page}
page <- "https://en.wikipedia.org/wiki/List_of_countries_by_GDP_(nominal)"
gdp <- rvest::read_html(page)
```

Then you can start by getting the text of the first paragraph.

```{r get_paragraph}
p1 <- gdp %>%
  html_elements("p") %>%
  html_text()
p1[3]
```

If you have found the XPath corresponding to the table that you are interested in, you can read the table.

```{r get_table}
gdp_df <- gdp %>%
  html_elements(xpath = '/html/body/div[2]/div/div[3]/main/div[3]/div[3]/div[1]/table[2]') %>%
  html_table() %>%
  .[[1]]
```

## 3. Getting data from an API

To get data from an API, you will need the base URL and the end point. It should be provided in the API documentation.

The base URL is: https<nolink>://api.fiscaldata.treasury.gov/services/api/fiscal_service

The end point is: /v1/accounting/mts/mts_table_1

Gathering both gives you [data](https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v1/accounting/mts/mts_table_1) in the JSON format.

```{r url}
url <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v1/accounting/mts/mts_table_1"
treasury_api <- GET(url)
```

You can then transform the JSON format into a data frame.

```{r json_to_df}
result <- content(treasury_api, "text", encoding="UTF-8")
df_json <- fromJSON(result, flatten=TRUE)
df <- as.data.frame(df_json$data)
```

## 4. Miscellaneous functions

This is a list of miscellaneous useful functions that we have not covered yet. The first one is used to apply the same function to all the columns in the data set.

```{r map}
mtcars %>% 
  select(hp, wt) %>%  map(mean)
```

This function is used to combine data sets by rows,

```{r bind_rows}
A <- mtcars[1:3, ]
B <- mtcars[4:6, ]
AB <- A %>% bind_rows(B)
```

and this one to combine data sets by columns.

```{r bind_cols}
A <- mtcars[1:5, 1:3]
B <- mtcars[1:5, 4:6]
 AB <- A %>% bind_cols(B)
```

This is another way of creating a new column with a condition on another column. It allows handling multiple cases of logical tests.

```{r case_when}
mtcars %>% 
  mutate(transmission_type = 
            case_when(
              am == 0 ~ "automatic",
              am == 1 ~ "manual"))
```
